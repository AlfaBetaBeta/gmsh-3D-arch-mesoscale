Geometry.ExtrudeReturnLateralEntities = 0;
Geometry.AutoCoherence = 0;

Macro CrtArchIntrf

// NOTES: * INITIALLY GENERATION TAKES PLACE IN THE (LOCAL) XY-PLANE, VIA EXTRUSIONS OF
//	    POINTS AND LINES
//	  * LOCAL X IS NOT PARALLEL TO GLOBAL X, IT IS ROTATED (Y-ROTATION) BY phi0
//	  * LOCAL Y IS PARALLEL TO GLOBAL Y
//	  * ONCE THE 'CROSS SECTION' IS DEFINED, EXTRUSION BY ROTATION ENSUES;
//	    THIS EXTRUSION IS LABELLED AS 'Z', ALTHOUGH STRICTLY SPEAKING IT
//	    UNFOLDS ALONG THE ARCH LONGITUDINAL DIRECTION
//	  * ORDER OF EXTRUSIONS IS THEN:
//		(1) POINT EXTRUSIONS ALONG (LOCAL) X
//		(2) LINE EXTRUSIONS ALONG (LOCAL=GLOBAL) Y
//		(3) SURFACE EXTRUSIONS ALONG 'Z' (ARCH LONG. DIRECTION)
//	  * THE AXIS OF ROTATION IS SET AS PARALLEL TO +Y 
//	  * THE LOCATION OF THE AXIS OF ROTATION IS OBTAINED BY SHIFTING THE Y-AXIS
//	    ALONG Radius
//----------------------------------------------------------------------------------
/*
IN:	br_x[] = {brick, interface} or {interface, brick} dimensions along X
	br_y[] = {brick, interface} or {interface, brick} dimensions along Y
	br_z[] = {brick, interface} or {interface, brick} dimensions along Z

	n_x    = Number of layers (including both bricks and interfaces) along
		 X in the 'cross section'
	n_y    = Number of layers (including both bricks and interfaces) along
		 Y in the 'cross section'
	***In n_x and n_y, the very 1st layer corresponds to either a BRICK or
	   to an INTERFACE depending on the ordering in br_*[]***

	Radius = Distance from (LOCAL)X=width/2 to the axis of rotation
	Angle  = Angle of rotation for the Surface extrusion (positive sign
		 given by rotation around +Y)
	Cphi0  = Cos(phi0), where phi0 is defined and obtained in macro InitEQSpIntrf
	Sphi0  = Sin(phi0), where phi0 is defined and obtained in macro InitEQSpIntrf

	StrtPt = PointID of the Point from which to start geometry generation

OUT:	n_z        = Number of layers along 'Z'/the arch longitudinal direction
	axis_rot[] = Coordinates of Point along axis of rotation, in the same Y-plane
		     as StrtPt 
	eee[]      =
	eeo[]  	   =
	eoe[]  	   =
	oee[]  	   =
	eoo[]  	   =
	ooe[]      =
	oeo[]  	   =
	ooo[]  	   =

	S_sprngS[] = List with (interface) Surfaces in the START springing
	S_sprngE[] = List with (interface) Surfaces in the END springing 

*/
//----------------------------------------------------------------------------------
// CALCULATE THE X-WIDTH OF THE 'CROSS SECTION' BASED ON br_x[] AND n_x:
width = 0;
For i In {0 : n_x-1}
	width += br_x[i%(#br_x[])];
EndFor
//----------------------------------------------------------------------------------
// OBTAIN THE NUMBER OF REQUIRED LAYERS IN 'Z':
length = Radius*Angle; Printf("Circumpherential length of arch = ", length);
ll = 0;
For i In {0 : #br_z[]-1}
	ll += br_z[i];
EndFor
// ENSURE LAST LAYER IS THE SAME AS 1ST LAYER BY ADDING +1
// (i.e. EITHER BOTH SPRINGINGS ARE BRICK OR BOTH ARE MORTAR)
n_z = Floor(length/ll)*(#br_z[]) + 1;
Printf("INFO: The number of circumferential layers is n_z = ", n_z);
//----------------------------------------------------------------------------------
// (1) POINT EXTRUSIONS ALONG X STARTING FROM GIVEN POINT StrtPt:
xyzStrtPt[] = Point{StrtPt};
out[] = {StrtPt};
next[] = {};
For i In {0 : n_x-1}
	extr = br_x[i%(#br_x[])];
	out[] = Extrude {extr*Cphi0, 0, -extr*Sphi0} {Point{out[0]}; Layers{1}; Recombine;};
	next[] = {next[], out[1]};
EndFor
// AT THIS POINT, next[] IS A LIST WITH ALL LineIDs GENERATED BY THE POINT EXTRUSIONS
// STARTING FROM StrtPt
Coherence;
//----------------------------------------------------------------------------------
// (2) LINE EXTRUSIONS ALONG Y TO GENERATE THE 'CROSS SECTION':
out[] = next[];
next[] = {};
For i In {0 : n_y-1}
	extr = br_y[i%(#br_y[])];
	out[] = Extrude {0, extr, 0} {Line{out[]}; Layers{1}; Recombine;};
	next[] = {next[], out[ {1 : #out[]-1 : 2} ]};
	out[] = {out[ {0 : #out[]-1 : 2} ]}; 
EndFor
// next[] AND out[] GENERATED BY SLICING AT INCREMENTS OF 2 BECAUSE OF THE SETTING
// OF THE ENVIRONMENT VARIABLE Geometry.ExtrudeReturnLateralEntities=0

// AT THIS POINT, next[] IS A LIST WITH ALL SurfaceIDs GENERATED BY EXTRUDING (n_y
// TIMES SUCCESSIVELY) THE LINES OF THE PREVIOUS BLOCK
S_sprngS[] = next[];
Coherence;
//----------------------------------------------------------------------------------
// (3) SURFACE EXTRUSIONS ALONG 'Z' (ARCH LONGITUDINAL DIRECTION):
out[] = next[];
next[] = {};
axis_rot[] = {xyzStrtPt[0]+(Radius+width/2)*Cphi0, xyzStrtPt[1],
              xyzStrtPt[2]-(Radius+width/2)*Sphi0};
For i In {0 : n_z-1}
	extr = br_z[i%(#br_z[])];
	out[] = Extrude { {0,1,0}, {axis_rot[0],axis_rot[1],axis_rot[2]}, extr/Radius }
                {Surface{out[]}; Layers{1}; Recombine; };
	next[] = {next[], out[ {1 : #out[]-1 : 2} ]};
	out[] = {out[ {0 : #out[]-1 : 2} ]};
EndFor
// next[] AND out[] GENERATED BY SLICING AT INCREMENTS OF 2 BECAUSE OF THE SETTING
// OF THE ENVIRONMENT VARIABLE Geometry.ExtrudeReturnLateralEntities=0

// AT THIS POINT, next[] IS A LIST WITH ALL VolumeIDs GENERATED BY EXTRUDING (n_z
// TIMES SUCCESSIVELY) THE SURFACES OF THE PREVIOUS BLOCK
S_sprngE[] = out[];
Coherence;
//----------------------------------------------------------------------------------
// INITIALISE LISTS FOR GROUPING IN PHYSICAL ENTITIES:
eee[] = {};
eeo[] = {};
eoe[] = {};
oee[] = {};
eoo[] = {};
ooe[] = {};
oeo[] = {};
ooo[] = {};
//----------------------------------------------------------------------------------
// LOOP OVER ALL VOLUMES VIA z_index (LAYER COUNTER STARTING FROM ZERO, WHERE A LAYER
// IS MADE OF (n_x * n_y) ELEMENTS).
// FOR EACH z_index:
//	jj RANGES BETWEEN 0 AND (n_x * n_y)
//	x_index RANGES BETWEEN 0 AND (n_x - 1)
//	y_index RANGES BETWEEN 0 AND (n_y - 1)
// EACH VOLUME IS THEN REPRESENTED BY A UNIQUE TRIPLET (x_index, y_index, z_index)
// EACH INDEX CAN BE EVEN ('e') OR ODD ('o')
// ONLY 1 LIST CONTAINS BRICKS! ANY OTHER LIST, WITH AT LEAST ONE 'e/o'PERMUTATION,
// CONTAINS JOINTS 

For j In {0 : #next[]-1}
	z_index = Floor(j/(n_x*n_y));
	jj = j%(n_x*n_y);
	y_index = Floor(jj/n_x);
	x_index = jj%n_x;
	If (x_index%2 == 0)
		If (y_index%2 == 0)
			If (z_index%2 == 0)
				eee[] = {eee[], next[j]};
			Else
				eeo[] = {eeo[], next[j]};
			EndIf
		Else
			If (z_index%2==0)
				eoe[]={eoe[],next[j]};
			Else
				eoo[]={eoo[],next[j]};
			EndIf
		EndIf
	Else
		If (y_index%2==0)
			If (z_index%2==0)
				oee[]={oee[],next[j]};
			Else
				oeo[]={oeo[],next[j]};
			EndIf
		Else
			If (z_index%2==0)
				ooe[]={ooe[],next[j]};
			Else
				ooo[]={ooo[],next[j]};
			EndIf
		EndIf
	EndIf
EndFor
//----------------------------------------------------------------------------------
Return
